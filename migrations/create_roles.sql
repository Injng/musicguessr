-- Create types for permissions and roles
CREATE TYPE public.app_permission AS ENUM ('artists.insert', 'pieces.insert', 'recordings.insert', 'set_recordings.insert', 'set_recordings.delete', 'sets.insert', 'sets.delete');
CREATE TYPE public.app_role AS ENUM ('admin', 'player');

-- Create the user roles table
CREATE TABLE public.user_roles
(
    id      BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
    role    app_role                                     NOT NULL,
    UNIQUE (user_id, role)
);
COMMENT
ON TABLE public.user_roles IS 'Application roles for each user.';

-- Create the user role permission table
CREATE TABLE public.role_permissions
(
    id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role       app_role       NOT NULL,
    permission app_permission NOT NULL,
    UNIQUE (role, permission)
);
COMMENT
ON TABLE public.role_permissions IS 'Application permissions for each role.';

-- Create the role permissions
INSERT INTO public.role_permissions (role, permission)
VALUES ('admin', 'artists.insert'),
       ('admin', 'pieces.insert'),
       ('admin', 'recordings.insert'),
       ('admin', 'set_recordings.insert'),
       ('admin', 'set_recordings.delete'),
       ('admin', 'sets.insert'),
       ('admin', 'sets.delete'),
       ('player', 'sets.insert');

-- Create the auth hook function
CREATE
OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
claims jsonb;
  user_role
public.app_role;
BEGIN
SELECT role
INTO user_role
FROM public.user_roles
WHERE user_id = (event ->>'user_id')::UUID;
claims
:= event->'claims';
  IF
user_role IS NOT NULL THEN
    claims := JSONB_SET(claims, '{user_role}', TO_JSONB(user_role));
ELSE
    claims := JSONB_SET(claims, '{user_role}', 'null');
END IF;
  event
:= JSONB_SET(event, '{claims}', claims);
RETURN event;
END;
$$;

GRANT USAGE ON SCHEMA
public TO supabase_auth_admin;

GRANT EXECUTE
    ON FUNCTION public.custom_access_token_hook
    TO supabase_auth_admin;

REVOKE EXECUTE
    ON FUNCTION public.custom_access_token_hook
    FROM authenticated, anon, public;

GRANT
ALL
ON TABLE public.user_roles
TO supabase_auth_admin;

REVOKE ALL
    ON TABLE public.user_roles
    FROM authenticated, anon, public;

CREATE
POLICY "Allow auth admin to read user roles" ON public.user_roles
AS PERMISSIVE FOR
SELECT
    TO supabase_auth_admin
    USING (TRUE);

-- Create authorize function for RLS
CREATE
OR REPLACE FUNCTION public.authorize( requested_permission app_permission)
RETURNS BOOLEAN AS $$
DECLARE
bind_permissions INT;
  user_role
public.app_role;
BEGIN
SELECT (auth.jwt() ->> 'user_role') ::public.app_role
INTO user_role;
SELECT COUNT(*)
INTO bind_permissions
FROM public.role_permissions
WHERE role_permissions.permission = requested_permission
  AND role_permissions.role = user_role;
RETURN bind_permissions > 0;
END;
$$
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = '';